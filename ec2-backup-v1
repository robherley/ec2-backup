#!/usr/bin/env python3
from subprocess import run, Popen, PIPE, CalledProcessError
from time import sleep
import argparse
import json

# From: https://wiki.netbsd.org/amazon_ec2/amis/
netbsd_amis = {
    'us-east-1': 'ami-bc8fc8d6',
    'us-west-1': 'ami-7b0b621b',
    'us-west-2': 'ami-9c9f8ffd',
    'eu-central-1': 'ami-32e6f45e',
    'eu-west-1': 'ami-ac983ddf',
    'ap-southeast-1': 'ami-c8ea2bab',
    'ap-southeast-2': 'ami-8a89d0e9',
    'ap-northeast-1': 'ami-d7eeccb9',
    'sa-east-1': 'ami-51d0553d'
}


def parse_args():
    """Parses command line arguments"""
    parser = argparse.ArgumentParser(description="""Creates an instance
                                     suitable for the specified volume,
                                     attaches the volume to the instance,
                                     and remotely logs in on the instance
                                     and displays the disklabel of the attached
                                     volume.""")
    parser.add_argument('-v', required=True, metavar="volume-id",
                        help="id of the volume to mount")
    return parser.parse_args()


def error(msg: str):
    print(f'ec2-backup-v1: error: {msg}')
    exit(1)


def run_aws(cmd: str) -> dict:
    """Given a string, run the aws command in a subprocess and parse the json
    output into a dict

    Arguments:
        cmd {str} -- command to execute

    Returns:
        dict -- parsed JSON output
    """

    try:
        proc = run(cmd + " --output json", shell=True,
                   check=True, capture_output=True)
        j = json.loads(proc.stdout)
        return j
    except CalledProcessError as e:
        error(f"an error occurred in the aws subprocess:\n{e}")
    except json.JSONDecodeError as e:
        error(f"unable to parse aws-cli output:\n{e}")
    except Exception as e:
        error(f"an unknown error has occurred:\n{e}")


def find_region_volume(id: str) -> (str, dict):
    """Finds an EBS volume based on a specified id

    Arguments:
        id {str} -- id of volume to find

    Returns:
        (str, dict) -- region name and information about the specified volume
    """

    def vol(r): return (f"aws ec2 describe-volumes --region {r} --query"
                        f" 'Volumes[0]' --volume-id {id}")
    procs = [(Popen(vol(i), shell=True, stdout=PIPE, stderr=PIPE), i)
             for i in netbsd_amis]
    for p in procs:
        p[0].wait()
    try:
        for [proc, region] in procs:
            if proc.returncode == 0:
                vol_info = json.loads(proc.stdout.read())
                if vol_info['State'] != 'available':
                    error((f"specified volume ({id}) is not available:"
                           f" status: {vol_info['State']}"))
                return region, vol_info
        error(
            f"specified volume ({id}) was not found in any supported regions")
    except json.JSONDecodeError as e:
        error(f"unable to parse aws-cli output:\n{e}")
    except Exception as e:
        error(f"\n{e}")


def print_disklabel(dns):
    try:
        cmd = (f"ssh root@{dns} '/sbin/disklabel /dev/xbd2 2>&1; exit 0'")
        proc = run(cmd, shell=True, check=True, capture_output=True)
        print(proc.stdout.decode('utf8'))
        return
    except CalledProcessError as e:
        error(f'an unknown occurred in the ssh subprocess:\n{e}')
    except Exception as e:
        error('an unknown error occurred while attempting to ssh')


class EC2Instance:
    instance_type = "t1.micro"
    key_name = "ec2-backup"
    sg_name = "default"

    def __init__(self, ami_id, region, vol):
        self.ami_id = ami_id
        self.region = region
        self.vol = vol

    def start(self):
        self.id = run_aws((f"aws ec2 run-instances --image-id {self.ami_id} "
                           f"--count 1 --instance-type {self.instance_type} "
                           f"--key-name {self.key_name} "
                           f"--security-groups {self.sg_name} --region "
                           f"{self.region} --query 'Instances[0].InstanceId' "
                           "--placement 'AvailabilityZone="
                           f"{self.vol['AvailabilityZone']}'"))

    def debug_info(self):
        print("Region:", self.region)
        print("AMI ID:", self.ami_id)
        print("Security Group:", self.sg_name)
        print('Instance Id:', self.id)
        print('Volume Info:', self.vol)

    def get_dns(self) -> str:
        dns = run_aws(("aws ec2 describe-instances --instance-ids "
                       f"{self.id} --region {self.region} "
                       "--query 'Reservations[0].Instances[0].PublicDnsName'"))
        return dns

    def wait_for_ready(self):
        ready = False
        while not ready:
            status = run_aws("aws ec2 describe-instance-status --instance-id "
                             f"{self.id} --query 'InstanceStatuses[0]' "
                             f"--region {self.region}")
            if not status:
                sleep(2)
                continue
            ready = status['InstanceState']['Name'] == "running"

    def attach_volume(self):
        run_aws(("aws ec2 attach-volume --device /dev/sdx --instance-id "
                 f"{self.id} --volume-id {self.vol['VolumeId']}"
                 f" --region {self.region}"))

    def terminate(self):
        run_aws((f"aws ec2 terminate-instances --instance-ids "
                 f"'{self.id}' --region {self.region}"))


def main():
    args = parse_args()
    region, vol = find_region_volume(args.v)
    inst = EC2Instance(netbsd_amis[region], region, vol)
    inst.start()
    inst.wait_for_ready()
    dns = inst.get_dns()
    inst.attach_volume()
    print_disklabel(dns)
    inst.terminate()


if __name__ == "__main__":
    main()
